{"version":3,"sources":["_init.js","Create.js","Empty.js","Respond.js","types.js","Connection/REST.js","Connection/RPC.js","Connection/WebSocket.js","Connection/Webhook.js","Event/Error.js","Event/Invalidated.js","Event/RateLimit.js","Event/TypingStart.js","Event/Warn.js","Interaction/Defer.js","Interaction/Reply.js","Message/Delete.js","Message/Modify.js","Message/Send.js","SlashCommand/Create.js","SlashCommand/GetOption.js","SlashCommand/Register.js","utils/NodeToast.js","Bot/Set/Activity.js","Bot/Set/Avatar.js","Bot/Set/Status.js","Bot/Set/Username.js","Event/Channel/Create.js","Event/Channel/Delete.js","Event/Channel/Update.js","Event/Emoji/Create.js","Event/Emoji/Delete.js","Event/Emoji/Update.js","Event/Guild/Create.js","Event/Guild/Delete.js","Event/Guild/IntegrationsUpdate.js","Event/Guild/Unavailable.js","Event/Guild/Update.js","Event/Interaction/Create.js","Event/Invite/Create.js","Event/Invite/Delete.js","Event/Message/Create.js","Event/Message/Delete.js","Event/Message/DeleteBulk.js","Event/Message/Update.js","Event/Role/Create.js","Event/Role/Delete.js","Event/Role/Update.js","Event/Stage/Create.js","Event/Stage/Delete.js","Event/Stage/Update.js","Event/Sticker/Create.js","Event/Sticker/Delete.js","Event/Sticker/Update.js","Event/Thread/Create.js","Event/Thread/Delete.js","Event/Thread/ListSync.js","Event/Thread/MembersUpdate.js","Event/Thread/Update.js","Event/User/PresenceUpdate.js","Event/User/Update.js","Event/Voice/StateUpdate.js","Event/Webhook/Update.js","Interaction/Modal/Create.js","Interaction/Modal/TextInput.js","Message/Reaction/AddReaction.js","Event/Channel/Pins/Update.js","Event/Guild/Ban/Add.js","Event/Guild/Ban/Remove.js","Event/Guild/Member/Add.js","Event/Guild/Member/Available.js","Event/Guild/Member/Chunk.js","Event/Guild/Member/Remove.js","Event/Guild/Member/Update.js","Event/Guild/ScheduledEvent/Create.js","Event/Guild/ScheduledEvent/Delete.js","Event/Guild/ScheduledEvent/Update.js","Event/Guild/ScheduledEvent/UserAdd.js","Event/Guild/ScheduledEvent/UserRemove.js","Event/Message/Reaction/Add.js","Event/Message/Reaction/Remove.js","Event/Message/Reaction/RemoveAll.js","Event/Message/Reaction/RemoveEmoji.js","Interaction/Modal/GetValue/TextInput.js"],"names":["_class","_class2","_class4","_class5","_class6","_class7","_class8","_class9","_class10","_class11","_class12","_class13","_class14","_class15","_class16","_class17","_class18","_class19","_class20","_class21","_class22","_class23","_class24","_class25","_class26","_class27","_class28","_class29","_class30","_class31","_class32","_class33","_class34","_class35","_class36","_class37","_class38","_class39","_class40","_class41","_class42","_class43","_class44","_class45","_class46","_class47","_class48","_class49","_class50","_class51","_class52","_class53","_class54","_class55","_class56","_class57","_class58","_class59","_class60","_class61","_class62","_class63","_class64","_class65","_class66","_class67","_class68","_class69","_class70","_class71","_class72","_class73","_class74","_class75","_class76","_class77","_class78","_class79","_class80","_class81","window","globalThis","async","imports","urls","sf","loader","mjs","Promise","all","map","v","import","task","Blackprint","loadScope","url","hasInterface","hasDocs","DiscordLib","Environment","isNode","process","cwd","_fType","fType","obj","name","type","deepProperty","split","Error","temp","Object","defineProperty","value","path","i","length","Context","createContext","DiscordType","EventSlot","slot","AutocompleteCreate","constructor","node","Input","Output","ref","this","Name","toLowerCase","description","Description","Choices","str","choices","required","Required","_node","toJSON","autocomplete","_class3","registerNode","Node","instance","super","setInterface","title","request","update","test","Data","handle","interaction","output","Requested","input","String","Boolean","Port","ArrayOf","Interaction","isAutocomplete","respond","Types","User","StructOf","Id","field","Bot","Username","Discriminator","Avatar","AccentColor","BaseChannel","Members","Map","Messages","Guild","data","members","cache","Channels","isBrowser","AccessToken","Client","REST","version","setToken","iface","_toast","NodeToast","warn","setTimeout","syncOut","connect","IntentsBits","destroy","Ready","client","intents","IntentsBitField","once","login","syncIn","id","val","toast","clear","success","disconnect","Connect","Trigger","port","Disconnect","Default","Number","init","IInput","on","unlisten","off","_callback","deferReply","send","reply","content","Content","ephemeral","Ephemeral","awaitMessageComponent","Message","message","Exec","Deleted","delete","Success","edit","TextChannel","SlashCommandCreate","Autocompletes","options","Command","interacted","Interacted","handleAutocomplete","focusedOpt","getFocused","get","e","Any","Event","cable","isChatInputCommand","GuildId","Commands","guildId","command","commandName","put","Routes","applicationGuildCommands","AppId","body","haveInfo","haveWarn","haveError","_reduceText","text","replace","full","slice","info","$decoration","_raw","error","Text","user","setActivity","Type","URL","setAvatar","Status","setStatus","setUsername","isButton","isCommand","isContextMenuCommand","isMessageComponent","isMessageContextMenuCommand","isModalSubmit","isSelectMenu","isUserContextMenuCommand","registerInterface","Interface","msg","author","bot","CreatedAt","Date","Author","Channel","modalCreateId","_customId","_listen","listen","ev","customId","UserSubmit","_client","_unlisten","exec","Rows","modal","ModalBuilder","setCustomId","setTitle","Title","rows","addComponents","ActionRowBuilder","showModal","CustomId","Label","TextInputBuilder","setLabel","setStyle","Style","Emoji","Reacted","react","fields","getTextInputValue"],"mappings":"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","file":"nodes-discord.mjs","sourcesContent":["// Let the Blackprint Editor know the source URL where\n// the registerNode and registerInterface belongs to\nlet Blackprint = window.Blackprint.loadScope({\n\t// You can find the URL on Blackprint menu -> Modules\n\t// This will also be exported to JSON if this module's nodes is being used\n\turl: import.meta.url,\n\n\t// This will autoload (*.sf.mjs) and (*.sf.css) file for Browser\n\thasInterface: true,\n\n\t// This will autoload (*.docs.json) for Browser\n\thasDocs: true,\n});\n\nlet DiscordLib = {};\nif(Blackprint.Environment.isNode)\n\tDiscordLib = await import('file:'+process.cwd()+'/node_modules/discord.js/src/index.js');\n\n\n// Try obtain the class, if not exist then create fake type only for browser\nlet _fType = {};\nlet fType = function(obj, name){\n\tlet type = obj[name];\n\n\tif(type == null)\n\t\ttype = deepProperty(obj, name.split('.'));\n\n\tif(type != null) return type;\n\n\tif(Blackprint.Environment.isNode)\n\t\tthrow new Error(`'Discord.${name}' class contructor was not found`);\n\n\tif(_fType[name] == null){\n\t\tlet temp = _fType[name] = class{};\n\t\tObject.defineProperty(temp, 'name', {value: name});\n\t}\n\n\treturn _fType[name];\n}\n\nfunction deepProperty(obj, path){\n\tfor(var i = 0; i < path.length; i++){\n\t\tif((obj = obj[path[i]]) == null) return;\n\t}\n\n\treturn obj;\n}\n\n// Global shared context (share to _init.sf)\nlet Context = Blackprint.createContext('Discord');\n\n// Expose the fake types and the imported library so it can be accessed or extended by other module\nContext.DiscordType = fType;\nContext.DiscordLib = DiscordLib;\n\n// This is needed to avoid duplicated event listener when using hot reload\n// Event listener that registered with same slot will be replaced\nContext.EventSlot = {slot: 'my-private-event-slot'};","class AutocompleteCreate {\n\tconstructor(node){\n\t\tlet { Input, Output } = node.ref;\n\n\t\tthis.name = Input.Name.toLowerCase();\n\t\tthis.description = Input.Description;\n\n\t\tlet Choices = Input.Choices;\n\t\tChoices = Choices.length === 0 ? null : Choices.map(str => ({ name: str, value: str }));\n\t\tthis.choices = Choices;\n\n\t\tthis.required = Input.Required;\n\t\tthis._node = node;\n\t}\n\ttoJSON(){\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\ttype: 3, //https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-type\n\t\t\tdescription: this.description,\n\t\t\trequired: this.required,\n\t\t\tchoices: this.choices,\n\t\t\tautocomplete: this.choices === null,\n\t\t};\n\t}\n}\n\n/**\n * Create/prepare a autocomplete for slash command\n * @summary Discord.js Slash command\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/SlashCommand/Autocomplete/Create\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tName: String,\n\t\tDescription: String,\n\t\tRequired: Boolean,\n\t\tChoices: Blackprint.Port.ArrayOf(String),\n\t};\n\tstatic output = {\n\t\tData: AutocompleteCreate,\n\t\tRequested: fType(DiscordLib, 'BaseInteraction'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Create Autocomplete\";\n\t}\n\n\trequest(){this.update()}\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(!Input.Name) return;\n\n\t\tif(/^[-_\\p{L}\\p{N}\\p{sc=Deva}\\p{sc=Thai}]{1,32}$/mu.test(Input.Name) === false){\n\t\t\tthrow new Error(\"Invalid command name: \" + Input.Name);\n\t\t}\n\n\t\tOutput.Data = new AutocompleteCreate(this);\n\t}\n\n\thandle(interaction){\n\t\tthis.output.Requested = interaction;\n\t}\n});","if(false){ // Avoid executing line below when this file being compiled\n// You can just copy and paste code below as a template for creating nodes\n\nBlackprint.registerNode(\"Discord/FeatureName/Empty\",\nclass extends Blackprint.Node {\n\tstatic input = {};\n\tstatic output = {};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Empty\";\n\t}\n});\n\nBlackprint.registerInterface('BPIC/Discord/FeatureName/Empty',\nContext.IFace.Empty = class EmptyIFace extends Blackprint.Interface{\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\t// Add some properties for this object\n\t}\n});\n\nBlackprint.Sketch.registerInterface('BPIC/Discord/FeatureName/Empty', {\n\ttemplate: null\n}, Context.IFace.Empty);\n\n\n}","/**\n * Respond to slash command's autocomplete request\n * @summary Discord.js Slash Command\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/SlashCommand/Autocomplete/Respond\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t\n\t\tInteraction: fType(DiscordLib, 'BaseInteraction'),\n\t\tChoices: Blackprint.Port.ArrayOf(String),\n\t};\n\tstatic output = { };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Respond Autocomplete\";\n\t}\n\n\trequest(){this.update()}\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(!Input.Interaction?.isAutocomplete()) return;\n\n\t\tInput.Interaction.respond(Input.Choices.map(str => ({ name: str, value: str })));\n\t}\n});","let Types = {\n\tUser: Blackprint.Port.StructOf(fType(DiscordLib, 'User'), {\n\t\tId: {type: String, field: 'id'},\n\t\tBot: {type: Boolean, field: 'bot'},\n\t\tUsername: {type: String, field: 'username'},\n\t\tDiscriminator: {type: String, field: 'discriminator'},\n\t\tAvatar: {type: String, field: 'avatar'},\n\t\tAccentColor: {type: String, field: 'accentColor'},\n\t}),\n\tBaseChannel: Blackprint.Port.StructOf(fType(DiscordLib, 'BaseGuildTextChannel'), {\n\t\tId: {type: String, field: 'id'},\n\t\tName: {type: String, field: 'name'},\n\t\tMembers: {type: Map, field: 'members'},\n\t\tMessages: {type: fType(DiscordLib, 'MessageManager'), field: 'messages'},\n\t}),\n\tGuild: Blackprint.Port.StructOf(fType(DiscordLib, 'Guild'), {\n\t\tId: {type: String, field: 'id'},\n\t\tName: {type: String, field: 'name'},\n\t\tMembers: {type: Map, handle: data=> data.members.cache},\n\t\tChannels: {type: fType(DiscordLib, 'GuildChannelManager'), field: 'channels'},\n\t}),\n};\n","/**\n * Prepare REST connection to Discord's server\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Connection/REST\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tAccessToken: String,\n\t};\n\tstatic output = {\n\t\tClient: fType(DiscordLib, 'REST'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"REST\";\n\t}\n\n\tupdate(){\n\t\tif(Blackprint.Environment.isBrowser) return;\n\t\t\n\t\tlet { Input, Output } = this.ref;\n\t\tif(!Input.AccessToken) return;\n\n\t\t// Construct and prepare an instance of the REST module\n\t\tOutput.Client = new DiscordLib.REST({ version: '10' }).setToken(Input.AccessToken);\n\t}\n});","Blackprint.registerNode(\"Discord/Connection/RPC\",\nclass extends Blackprint.Node {\n\tstatic input = {};\n\tstatic output = {};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"RPC\";\n\t}\n});","/**\n * Initiate WebSocket connection to Discord's server\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Connection/WebSocket\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tConnect: Blackprint.Port.Trigger(port => port.iface.node.connect()),\n\t\tDisconnect: Blackprint.Port.Trigger(port => port.iface.node.disconnect()),\n\t\t/** Default to all intents except auto moderation */\n\t\tIntentsBits: Blackprint.Port.Default(Number, 131071),\n\t\tAccessToken: String,\n\t};\n\tstatic output = {\n\t\tClient: fType(DiscordLib, 'Client'),\n\t\tReady: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"WebSocket\";\n\t\tthis._toast = new NodeToast(iface);\n\n\t\tthis._toast.warn(\"Disconnected\");\n\t\tsetTimeout(() => this.syncOut(\"syncStatus\"), 600);\n\t}\n\n\tconnect(){\n\t\tlet { IntentsBits, AccessToken } = this.ref.Input;\n\t\tif(IntentsBits == null || !AccessToken) return;\n\n\t\tif(!Blackprint.Environment.isNode)\n\t\t\treturn this._toast.warn(\"Blackprint remote engine is required\");\n\n\t\tthis.syncOut(\"warn\", \"Connecting\");\n\n\t\tlet { Output } = this.ref;\n\t\tOutput.Client?.destroy();\n\t\tOutput.Ready = false;\n\t\tlet client = Output.Client = new DiscordLib.Client({ intents: new DiscordLib.IntentsBitField(IntentsBits) });\n\n\t\tclient.once('ready', () => {\n\t\t\tthis.syncOut(\"success\", \"Connected\");\n\t\t\tOutput.Ready = true;\n\t\t});\n\n\t\tclient.login(AccessToken);\n\t}\n\n\tsyncIn(id, val){\n\t\tif(id === 'syncStatus' && this.ref.Output.Ready){\n\t\t\tsetTimeout(() => this.syncOut(\"success\", \"Connected\"), 100);\n\t\t}\n\n\t\tif(!Blackprint.Environment.isBrowser) return;\n\n\t\tlet toast = this._toast;\n\t\tif(id === 'warn') toast.warn(val);\n\t\tif(id === 'success') {\n\t\t\ttoast.clear();\n\t\t\ttoast.success(val);\n\t\t}\n\t}\n\n\tdisconnect(){\n\t\tlet { Output } = this.ref;\n\n\t\tOutput.Client?.destroy();\n\t\tOutput.Ready = false;\n\n\t\tthis._toast.warn(\"Disconnected\");\n\t}\n});","Blackprint.registerNode(\"Discord/Connection/Webhook\",\nclass extends Blackprint.Node {\n\tstatic input = {};\n\tstatic output = {};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Webhook\";\n\t}\n});","/**\n * Listen for error from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Error\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Error\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('error', this._callback);\n\t\tclient.on('error', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen if bot request was invalidated\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Error\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Invalidated\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('invalidated', this._callback);\n\t\tclient.on('invalidated', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen if the bot was reached the rate limit\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Error\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Rate Limit\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('rateLimit', this._callback);\n\t\tclient.on('rateLimit', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for any typing event from someone\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Error\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Typing Start\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('typingStart', this._callback);\n\t\tclient.on('typingStart', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for any warning from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Warn\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Warn\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('warn', this._callback);\n\t\tclient.on('warn', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Respond to Discord server but we currently didn't want to send anything yet\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Interaction/Defer\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/** Channel where the message will be send */\n\t\tInteraction: fType(DiscordLib, 'BaseInteraction'),\n\t};\n\tstatic output = { };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Defer an interaction\";\n\t}\n\n\tupdate(){\n\t\tlet { Input } = this.ref; // Shortcut\n\t\tif(Input.Interaction == null) return;\n\n\t\tInput.Interaction.deferReply();\n\t}\n});","/**\n * Reply to user interaction\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Interaction/Reply\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tExec: Blackprint.Port.Trigger(port => port.iface.node.send()),\n\t\t/** Interaction object that will be replied */\n\t\tInteraction: fType(DiscordLib, 'BaseInteraction'),\n\t\t/** Text content of the message */\n\t\tContent: String,\n\t\t/** Show only for the user? */\n\t\tEphemeral: Boolean,\n\t};\n\tstatic output = {\n\t\tMessage: fType(DiscordLib, 'Message'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Reply an interaction\";\n\t}\n\n\tasync send(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Interaction == null) return;\n\n\t\tlet temp = await Input.Interaction.reply({\n\t\t\tcontent: Input.Content,\n\t\t\tephemeral: Input.Ephemeral,\n\t\t});\n\t\ttemp = await temp.awaitMessageComponent();\n\t\tOutput.Message = temp.message;\n\t}\n});","/**\n * Remove message from a channel\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Message/Delete\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tExec: Blackprint.Port.Trigger(port => port.iface.node.send()),\n\t\tMessage: fType(DiscordLib, 'Message'),\n\t};\n\tstatic output = {\n\t\t/**\n\t\t * Return true if the message was found and can be deleted\n\t\t * Return false if message was not found or has no permission to delete\n\t\t */\n\t\tDeleted: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Delete Message\";\n\t}\n\n\tasync send(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(Input.Message == null) return;\n\t\tOutput.Deleted = await Input.Message.delete();\n\t}\n});","/**\n * Edit or modify message\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Message/Modify\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tExec: Blackprint.Port.Trigger(port => port.iface.node.send()),\n\t\tMessage: fType(DiscordLib, 'Message'),\n\t\tContent: String,\n\t};\n\tstatic output = {\n\t\t/**\n\t\t * Return true if the message was edited\n\t\t * Return false if no permission or the message was gone\n\t\t */\n\t\tSuccess: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Modify Message\";\n\t}\n\n\tasync send(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Message == null || !Input.Content) return;\n\n\t\tOutput.Success = await Input.Message.edit(Input.Content);\n\t}\n});","/**\n * Send message to a text channel\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Message/Send\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tExec: Blackprint.Port.Trigger(port => port.iface.node.send()),\n\t\t/** Channel where the message will be send */\n\t\tTextChannel: fType(DiscordLib, 'BaseGuildTextChannel'),\n\t\t/** Text content of the message */\n\t\tContent: String,\n\t};\n\tstatic output = {\n\t\tMessage: fType(DiscordLib, 'Message'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Send Message\";\n\t}\n\n\tasync send(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.TextChannel == null || !Input.Content) return;\n\t\tOutput.Message = await Input.TextChannel.send(Input.Content);\n\t}\n});","class SlashCommandCreate {\n\tconstructor(node){\n\t\tlet { Input, Output } = node.ref;\n\n\t\tthis.name = Input.Name;\n\t\tthis.description = Input.Description;\n\n\t\tlet Autocompletes = Input.Autocompletes;\n\t\tAutocompletes = Autocompletes.length === 0 ? null : Autocompletes;\n\t\tthis.options = Autocompletes;\n\n\t\tthis._node = node;\n\t}\n\ttoJSON(){\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tdescription: this.description,\n\t\t\toptions: this.options,\n\t\t};\n\t}\n}\n\n/**\n * Create/prepare a slash command to be registered\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/SlashCommand/Create\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tName: String,\n\t\tDescription: String,\n\t\tAutocompletes: Blackprint.Port.ArrayOf(AutocompleteCreate),\n\t};\n\tstatic output = {\n\t\tCommand: SlashCommandCreate,\n\t\tInteracted: fType(DiscordLib, 'BaseInteraction'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Create Slash Commands\";\n\t}\n\n\trequest(){this.update()}\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(!Input.Name) return;\n\n\t\tOutput.Command = new SlashCommandCreate(this);\n\t}\n\n\tinteracted(interaction){\n\t\tthis.output.Interacted = interaction;\n\t}\n\n\thandleAutocomplete(interaction){\n\t\tlet { Input: { Autocompletes } } = this.ref; // Shortcut\n\t\tif(Autocompletes.length === 0) return;\n\n\t\tlet focusedOpt = interaction.options.getFocused(true);\n\n\t\tfor (let i=0; i < Autocompletes.length; i++) {\n\t\t\tlet temp = Autocompletes[i];\n\t\t\tif(temp.name === focusedOpt.name){\n\t\t\t\ttemp._node.handle(interaction);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n});","/**\n * Reply to user interaction\n * @summary Discord Slash Command\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/SlashCommand/GetOption\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/** Slash command interaction event */\n\t\tInteraction: fType(DiscordLib, 'BaseInteraction'),\n\t\t/** Slash command's option name */\n\t\tName: String,\n\t};\n\tstatic output = {\n\t\tData: Blackprint.Types.Any,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Get command option\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Interaction == null || !Input.Name) return;\n\n\t\ttry {\n\t\t\tOutput.Data = Input.Interaction.options.get(Input.Name.toLowerCase()).value;\n\t\t} catch(e) {\n\t\t\tOutput.Data = null;\n\t\t}\n\t}\n});","/**\n * Register slash command into a guild\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/SlashCommand/Register\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/** Client connection with REST */\n\t\tClient: fType(DiscordLib, 'REST'),\n\t\t/** Connect this port to InteractionCreate event output if you want to trigger command callback */\n\t\tEvent: fType(DiscordLib, 'BaseInteraction'),\n\t\tExec: Blackprint.Port.Trigger(port => port.iface.node.send()),\n\t\t/** Your application's client id, you can obtain from Discord Developer Portal */\n\t\tAppId: String,\n\t\t/** [Optional] You can leave this empty if you want to register globally */\n\t\tGuildId: String,\n\t\t/** A collection of slash commands */\n\t\tCommands: Blackprint.Port.ArrayOf(SlashCommandCreate),\n\t};\n\tstatic output = {\n\t\tSuccess: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Register Slash Commands\";\n\t}\n\n\tinit(){\n\t\tlet { IInput, Input } = this.ref; // Shortcut\n\t\tIInput.Event.on('value', ({ cable }) => {\n\t\t\tlet interaction = cable.value;\n\n\t\t\tif(!interaction.isChatInputCommand() && !interaction.isAutocomplete()) return;\n\t\t\tlet { GuildId, Commands } = Input;\n\n\t\t\t// Skip if the interaction was triggered for different guild\n\t\t\tif(!GuildId && GuildId !== interaction.guildId) return;\n\n\t\t\tfor (let i=0; i < Commands.length; i++) {\n\t\t\t\tlet command = Commands[i];\n\t\t\t\tif(command.name === interaction.commandName){\n\t\t\t\t\tif(interaction.isAutocomplete())\n\t\t\t\t\t\tcommand._node.handleAutocomplete(interaction);\n\t\t\t\t\telse \n\t\t\t\t\t\tcommand._node.interacted(interaction);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tasync send(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Client == null) return;\n\n\t\tlet GuildId = Input.GuildId;\n\t\tif(GuildId === '') GuildId = null;\n\n\t\ttry {\n\t\t\tawait Input.Client.put(DiscordLib.Routes.applicationGuildCommands(Input.AppId, Input.GuildId), {\n\t\t\t\tbody: Input.Commands\n\t\t\t});\n\t\t} catch(e) {\n\t\t\tOutput.Success = false;\n\t\t\tthrow e;\n\t\t}\n\n\t\tOutput.Success = true;\n\t}\n});","/**\n * import { Context } from \"./_init.js\";\n */\n\n// Bootstrap for add toast on node decoration\nlet NodeToast = Context.NodeToast = class NodeToast { // eslint-disable-line\n\tconstructor(iface){\n\t\tthis.iface = iface;\n\t}\n\n\tclear(){\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.destroy();\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.destroy();\n\t\tif(this.haveError)\n\t\t\tthis.haveError.destroy();\n\n\t\tthis.haveInfo = false;\n\t\tthis.haveWarn = false;\n\t\tthis.haveError = false;\n\t}\n\n\t_reduceText(text){\n\t\treturn text.replace(/\\w{15,}/g, full => full.slice(0, 5)+'...');\n\t}\n\n\tinfo(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.text = text;\n\t\telse\n\t\t\tthis.haveInfo = this.iface.$decoration.info(text);\n\n\t\tthis.haveInfo._raw = temp;\n\t}\n\n\twarn(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.text = text;\n\t\telse\n\t\t\tthis.haveWarn = this.iface.$decoration.warn(text);\n\n\t\tthis.haveWarn._raw = temp;\n\t}\n\n\terror(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveError)\n\t\t\tthis.haveError.text = text;\n\t\telse\n\t\t\tthis.haveError = this.iface.$decoration.error(text);\n\n\t\tthis.haveError._raw = temp;\n\t}\n\n\tsuccess(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet ref = this.iface.$decoration.success(this._reduceText(text));\n\t\tref._raw = text;\n\t}\n}","/**\n * Set bot activity\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Bot/Set/Activity\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tClient: fType(DiscordLib, 'Client'),\n\t\t/**\n\t\t * 0 = Playing\n\t\t * 1 = Streaming\n\t\t * 2 = Listening\n\t\t * 3 = Watching\n\t\t * 4 = Custom\n\t\t * 5 = Competing\n\t\t */\n\t\tType: Blackprint.Port.Default(Number, 0),\n\t\tText: String,\n\t};\n\tstatic output = {};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Set bot's activity\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Client == null || !Input.Text) return;\n\n\t\tInput.Client.user.setActivity(Input.Text, { type: Input.Type });\n\t}\n});","/**\n * Set bot activity\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Bot/Set/Avatar\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tClient: fType(DiscordLib, 'Client'),\n\t\tURL: String,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Set bot's avatar\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Client == null || !Input.URL) return;\n\n\t\tInput.Client.user.setAvatar(Input.URL);\n\t}\n});","/**\n * Set bot status\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Bot/Set/Status\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tClient: fType(DiscordLib, 'Client'),\n\t\t/**\n\t\t * online = Online\n\t\t * idle = Idle\n\t\t * dnd = Busy\n\t\t * invisible = Invisible\n\t\t */\n\t\tStatus: Blackprint.Port.Default(String, 'online'),\n\t};\n\tstatic output = {};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Set bot's status\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Client == null || !Input.Status) return;\n\n\t\tInput.Client.user.setStatus(Input.Status);\n\t}\n});","/**\n * Set bot activity\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Bot/Set/Username\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tClient: fType(DiscordLib, 'Client'),\n\t\tUsername: String,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Set bot's username\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Client == null || !Input.Username) return;\n\n\t\tInput.Client.user.setUsername(Input.Username);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Channel/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Channel Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('channelCreate', this._callback);\n\t\tclient.on('channelCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Channel/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Channel Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('channelDelete', this._callback);\n\t\tclient.on('channelDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Channel/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Channel Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('channelUpdate', this._callback);\n\t\tclient.on('channelUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Emoji/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Emoji Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('emojiCreate', this._callback);\n\t\tclient.on('emojiCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Emoji/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Emoji Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('emojiDelete', this._callback);\n\t\tclient.on('emojiDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Emoji/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Emoji Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('emojiUpdate', this._callback);\n\t\tclient.on('emojiUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildCreate', this._callback);\n\t\tclient.on('guildCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildDelete', this._callback);\n\t\tclient.on('guildDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/IntegrationsUpdate\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild IntegrationsUpdate\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildIntegrationsUpdate', this._callback);\n\t\tclient.on('guildIntegrationsUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Unavailable\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Unavailable\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildUnavailable', this._callback);\n\t\tclient.on('guildUnavailable', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildUpdate', this._callback);\n\t\tclient.on('guildUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Interaction/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: fType(DiscordLib, 'BaseInteraction'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Discord/Event/Interaction/Create');\n\t\tiface.title = \"Interaction Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('interactionCreate', this._callback);\n\t\tclient.on('interactionCreate', this._callback = (data) => {\n\t\t\tlet type = this.iface.data.type;\n\n\t\t\t// Interaction type check\n\t\t\tif(type === 0){} // Any interaction type\n\t\t\telse if(type === 1){ if(!data.isButton()) return; }\n\t\t\telse if(type === 2){ if(!data.isAutocomplete()) return; }\n\t\t\telse if(type === 3){ if(!data.isChatInputCommand()) return; }\n\t\t\telse if(type === 4){ if(!data.isCommand()) return; }\n\t\t\telse if(type === 5){ if(!data.isContextMenuCommand()) return; }\n\t\t\telse if(type === 6){ if(!data.isMessageComponent()) return; }\n\t\t\telse if(type === 7){ if(!data.isMessageContextMenuCommand()) return; }\n\t\t\telse if(type === 8){ if(!data.isModalSubmit()) return; }\n\t\t\telse if(type === 9){ if(!data.isSelectMenu()) return; }\n\t\t\telse if(type === 10){ if(!data.isUserContextMenuCommand()) return; }\n\n\t\t\tOutput.Data = data;\n\t\t});\n\t}\n\n\tsyncIn(id, data){\n\t\tif(id === 'type') this.data.type = data;\n\t}\n});\n\nBlackprint.registerInterface('BPIC/Discord/Event/Interaction/Create', \nclass extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\t\tthis.data = {type: 0}; // Default any interaction\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Invite/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Invite Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('inviteCreate', this._callback);\n\t\tclient.on('inviteCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Invite/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Invite Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('inviteDelete', this._callback);\n\t\tclient.on('inviteDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for new message created on from any guild channel that visible by the bot\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Blackprint.Port.StructOf(fType(DiscordLib, 'Message'), {\n\t\t\t/** Message Id */\n\t\t\tId: { type: String, field: 'id' },\n\t\t\t/** Message Content */\n\t\t\tContent: { type: String, field: 'content' },\n\t\t\t/** Message Creation Date */\n\t\t\tCreatedAt: { type: Date, field: 'createdAt' },\n\t\t\t/** Message Author */\n\t\t\tAuthor: { type: Types.User, field: 'author' },\n\t\t\t/** Channel where the message was sent */\n\t\t\tChannel: { type: Types.BaseChannel, field: 'channel' },\n\t\t\t/** Guild where the message was sent */\n\t\t\tGuild: { type: Types.Guild, field: 'guild' },\n\n\t\t\t/** Thread where the message was sent */\n\t\t\t// Thread: { type: fType(DiscordLib, 'ThreadChannel'), field: 'Thread' },\n\t\t}),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Create\";\n\n\t\t// Node type: event listener\n\t\tiface.type = 'event';\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tif(client == null) return;\n\n\t\tthis.unlisten = () => client.off('messageCreate', this._callback);\n\t\tclient.on('messageCreate', this._callback = (msg) => {\n\t\t\tif(msg.author?.bot) return; // Skip bot event\n\t\t\tOutput.Data = msg;\n\t\t});\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('messageDelete', this._callback);\n\t\tclient.on('messageDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/DeleteBulk\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Bulk Deletion\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('messageDeleteBulk', this._callback);\n\t\tclient.on('messageDeleteBulk', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('messageUpdate', this._callback);\n\t\tclient.on('messageUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Role/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Role Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('roleCreate', this._callback);\n\t\tclient.on('roleCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Role/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Role Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('roleDelete', this._callback);\n\t\tclient.on('roleDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Role/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Role Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('roleUpdate', this._callback);\n\t\tclient.on('roleUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Stage/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Stage Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('stageInstanceCreate', this._callback);\n\t\tclient.on('stageInstanceCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Stage/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Stage Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('stageInstanceDelete', this._callback);\n\t\tclient.on('stageInstanceDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Stage/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Stage Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('stageInstanceUpdate', this._callback);\n\t\tclient.on('stageInstanceUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Sticker/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Sticker Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('stickerCreate', this._callback);\n\t\tclient.on('stickerCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Sticker/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Sticker Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('stickerDelete', this._callback);\n\t\tclient.on('stickerDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Sticker/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Sticker Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('stickerUpdate', this._callback);\n\t\tclient.on('stickerUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Thread/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Thread Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('threadCreate', this._callback);\n\t\tclient.on('threadCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Thread/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Thread Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('threadDelete', this._callback);\n\t\tclient.on('threadDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Thread/ListSync\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Thread ListSync\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('threadListSync', this._callback);\n\t\tclient.on('threadListSync', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Channel/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Channel Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\t// ToDo: there are 'threadMemberUpdate' event too, should we add it?\n\t\tthis.unlisten = () => client.off('threadMembersUpdate', this._callback);\n\t\tclient.on('threadMembersUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Thread/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Thread Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('threadUpdate', this._callback);\n\t\tclient.on('threadUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\n Blackprint.registerNode(\"Discord/Event/User/PresenceUpdate\",\n class extends Blackprint.Node {\n\t // Node type: event listener\n\t static type = 'event';\n \n\t static input = {\n\t\t /** Websocket client connection */\n\t\t Client: fType(DiscordLib, 'Client'),\n\t };\n\t static output = {\n\t\t /** Response data */\n\t\t Data: Object,\n\t };\n \n\t constructor(instance){\n\t\t super(instance);\n \n\t\t let iface = this.setInterface();\n\t\t iface.title = \"User Presence Update\";\n\t }\n \n\t init(){\n\t\t // Listen if the cable was disconnected from the input port\n\t\t this.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t }\n \n\t update(){\n\t\t this.unlisten?.(); // Remove old event if exist\n \n\t\t let { Input, Output } = this.ref; // Shortcut\n\t\t let client = Input.Client; // Store reference to variable\n \n\t\t this.unlisten = () => client.off('presenceUpdate', this._callback);\n\t\t client.on('presenceUpdate', this._callback = (data) => Output.Data = data);\n\t }\n });","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/User/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"User Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('userUpdate', this._callback);\n\t\tclient.on('userUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\n Blackprint.registerNode(\"Discord/Event/Voice/StateUpdate\",\n class extends Blackprint.Node {\n\t // Node type: event listener\n\t static type = 'event';\n \n\t static input = {\n\t\t /** Websocket client connection */\n\t\t Client: fType(DiscordLib, 'Client'),\n\t };\n\t static output = {\n\t\t /** Response data */\n\t\t Data: Object,\n\t };\n \n\t constructor(instance){\n\t\t super(instance);\n \n\t\t let iface = this.setInterface();\n\t\t iface.title = \"Voice State Update\";\n\t }\n \n\t init(){\n\t\t // Listen if the cable was disconnected from the input port\n\t\t this.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t }\n \n\t update(){\n\t\t this.unlisten?.(); // Remove old event if exist\n \n\t\t let { Input, Output } = this.ref; // Shortcut\n\t\t let client = Input.Client; // Store reference to variable\n \n\t\t this.unlisten = () => client.off('voiceStateUpdate', this._callback);\n\t\t client.on('voiceStateUpdate', this._callback = (data) => Output.Data = data);\n\t }\n });","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\n Blackprint.registerNode(\"Discord/Event/Webhook/Update\",\n class extends Blackprint.Node {\n\t // Node type: event listener\n\t static type = 'event';\n \n\t static input = {\n\t\t /** Websocket client connection */\n\t\t Client: fType(DiscordLib, 'Client'),\n\t };\n\t static output = {\n\t\t /** Response data */\n\t\t Data: Object,\n\t };\n \n\t constructor(instance){\n\t\t super(instance);\n \n\t\t let iface = this.setInterface();\n\t\t iface.title = \"Webhook Update\";\n\t }\n \n\t init(){\n\t\t // Listen if the cable was disconnected from the input port\n\t\t this.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t }\n \n\t update(){\n\t\t this.unlisten?.(); // Remove old event if exist\n \n\t\t let { Input, Output } = this.ref; // Shortcut\n\t\t let client = Input.Client; // Store reference to variable\n \n\t\t this.unlisten = () => client.off('webhookUpdate', this._callback);\n\t\t client.on('webhookUpdate', this._callback = (data) => Output.Data = data);\n\t }\n });","let modalCreateId = 0;\n\n/**\n * Create modal for replying to user interaction\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Interaction/Modal/Create\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tExec: Blackprint.Port.Trigger(port => port.iface.node.exec()),\n\t\t/** Interaction object that will be replied */\n\t\tInteraction: fType(DiscordLib, 'BaseInteraction'),\n\t\t/** Modal title */\n\t\tTitle: String,\n\t\t/** Modal rows */\n\t\tRows: Blackprint.Port.ArrayOf(fType(DiscordLib, 'TextInputBuilder')),\n\t};\n\tstatic output = {\n\t\t/** This will have a value after user submitted the form/modal */\n\t\tUserSubmit: fType(DiscordLib, 'BaseInteraction'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Reply an interaction\";\n\n\t\tthis._customId = \"modal\" + (++modalCreateId);\n\t}\n\n\t_listen(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tlet client = Input.Interaction.client;\n\t\tif(this._client === client) return;\n\t\tthis._client = client;\n\n\t\tthis._unlisten?.();\n\t\tthis._unlisten = () => client.off('interactionCreate', listen);\n\t\tclient.on('interactionCreate', listen);\n\n\t\tfunction listen(ev){\n\t\t\tif(!ev.isModalSubmit() || ev.customId !== this._customId) return;\n\t\t\tOutput.UserSubmit = ev;\n\t\t}\n\t}\n\n\tasync exec(){\n\t\tlet { Input } = this.ref; // Shortcut\n\t\tif(Input.Interaction == null || Input.Rows.length === 0) return;\n\n\t\tlet modal = new DiscordLib.ModalBuilder();\n\t\tmodal.setCustomId(this._customId);\n\t\tmodal.setTitle(Input.Title);\n\n\t\tlet rows = Input.Rows;\n\t\tfor (let i=0; i < rows.length; i++) {\n\t\t\tmodal.addComponents(new ActionRowBuilder().addComponents(rows[i]));\n\t\t}\n\n\t\tawait Input.Interaction.showModal(modal);\n\t}\n\n\tdestroy(){\n\t\tthis._unlisten?.();\n\t}\n});","/**\n * Create text input box for modal\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Interaction/Modal/TextInput\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\t/** Input box's customId */\n\t\tCustomId: String,\n\t\t/** Input box's label */\n\t\tLabel: String,\n\t\t/**\n\t\t * Input box's style\n\t\t * @menu\n\t\t * - [short]:(Short) = One line text input box\n\t\t * - [paragraph]:(Paragraph) = Paragraph text input box\n\t\t */\n\t\tStyle: Blackprint.Port.Default(String, 'short'),\n\t};\n\tstatic output = {\n\t\tObject: fType(DiscordLib, 'TextInputBuilder'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Text input box\";\n\t}\n\n\trequest(){this.update()}\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(!Input.CustomId || !Input.Label) return;\n\n\t\tOutput.Object = new DiscordLib.TextInputBuilder()\n\t\t\t.setCustomId(Input.CustomId)\n\t\t\t.setLabel(Input.Label)\n\t\t\t.setStyle(Input.Style);\n\t}\n});","/**\n * Give emoji reaction to a message\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Message/Reaction/Add\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tExec: Blackprint.Port.Trigger(port => port.iface.node.send()),\n\t\tMessage: fType(DiscordLib, 'Message'),\n\t\t/** You can use regular emoji, or using the emoji ID */\n\t\tEmoji: String,\n\t};\n\tstatic output = {\n\t\tReacted: fType(DiscordLib, 'MessageReaction'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Add Message Reaction\";\n\t}\n\n\tasync send(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(Input.Message == null || !Input.Emoji) return;\n\t\tOutput.Reacted = await Input.Message.react(Input.Emoji);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Channel/Pins/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Channel Pins Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('channelPinsUpdate', this._callback);\n\t\tclient.on('channelPinsUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Ban/Add\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Ban Add\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildBanAdd', this._callback);\n\t\tclient.on('guildBanAdd', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Ban/Remove\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Ban Remove\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildBanRemove', this._callback);\n\t\tclient.on('guildBanRemove', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Member/Add\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Member Add\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildMemberAdd', this._callback);\n\t\tclient.on('guildMemberAdd', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Member/Available\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Member Available\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildMemberAvailable', this._callback);\n\t\tclient.on('guildMemberAvailable', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Member/Chunk\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Member Chunk\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildMembersChunk', this._callback);\n\t\tclient.on('guildMembersChunk', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Member/Remove\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Member Remove\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildMemberRemove', this._callback);\n\t\tclient.on('guildMemberRemove', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/Member/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild Member Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildMemberUpdate', this._callback);\n\t\tclient.on('guildMemberUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/ScheduledEvent/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild ScheduledEvent Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildScheduledEventCreate', this._callback);\n\t\tclient.on('guildScheduledEventCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/ScheduledEvent/Delete\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild ScheduledEvent Delete\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildScheduledEventDelete', this._callback);\n\t\tclient.on('guildScheduledEventDelete', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/ScheduledEvent/Update\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild ScheduledEvent Update\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildScheduledEventUpdate', this._callback);\n\t\tclient.on('guildScheduledEventUpdate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/ScheduledEvent/Create\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild ScheduledEvent Create\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('emojiCreate', this._callback);\n\t\tclient.on('emojiCreate', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Guild/ScheduledEvent/UserRemove\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Guild ScheduledEvent UserRemove\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('guildScheduledEventUserRemove', this._callback);\n\t\tclient.on('guildScheduledEventUserRemove', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/Reaction/Add\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Reaction Add\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('messageReactionAdd', this._callback);\n\t\tclient.on('messageReactionAdd', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/Reaction/Remove\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Reaction Remove\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('messageReactionRemove', this._callback);\n\t\tclient.on('messageReactionRemove', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/Reaction/RemoveAll\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Reaction Remove All\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('messageReactionRemoveAll', this._callback);\n\t\tclient.on('messageReactionRemoveAll', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Listen for event from the client\n * @summary Discord\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Event/Message/Reaction/RemoveEmoji\",\nclass extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\tstatic input = {\n\t\t/** Websocket client connection */\n\t\tClient: fType(DiscordLib, 'Client'),\n\t};\n\tstatic output = {\n\t\t/** Response data */\n\t\tData: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Message Reaction Remove Emoji\";\n\t}\n\n\tinit(){\n\t\t// Listen if the cable was disconnected from the input port\n\t\tthis.ref.IInput.Client.on('disconnect', Context.EventSlot, ()=> this.unlisten?.());\n\t}\n\n\tupdate(){\n\t\tthis.unlisten?.(); // Remove old event if exist\n\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet client = Input.Client; // Store reference to variable\n\n\t\tthis.unlisten = () => client.off('messageReactionRemoveEmoji', this._callback);\n\t\tclient.on('messageReactionRemoveEmoji', this._callback = (data) => Output.Data = data);\n\t}\n});","/**\n * Get text input box's value from modal/form submission\n * @summary Discord.js\n * @blackprint node\n */\nBlackprint.registerNode(\"Discord/Interaction/Modal/GetValue/TextInput\",\nclass extends Blackprint.Node {\n\tstatic input = {\n\t\tInteraction: fType(DiscordLib, 'BaseInteraction'),\n\t\t/** Input box's customId */\n\t\tCustomId: String,\n\t};\n\tstatic output = {\n\t\tText: String,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Text input value\";\n\t}\n\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tif(!Input.Interaction || !Input.CustomId) return;\n\n\t\tOutput.Text = Input.Interaction.fields.getTextInputValue(Input.CustomId);\n\t}\n});"]}